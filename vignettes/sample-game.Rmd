---
title: "Sample Game"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.width=8,
  fig.height=8
)
```

## Intro

This just shows a brief example of how you can start a game and trigger turns to progress.

```{r, include=FALSE}
devtools::load_all()
if (fs::dir_exists(file.path(GAME_ROOT_DIR, "anno_uno"))) fs::dir_delete(file.path(GAME_ROOT_DIR, "anno_uno"))
```
```{r}
library(MundusCentrum)
```

### Setup the game

```{r}
game <- new_game(
  name = "Anno Uno",
  players = list(
    list(
      name = "Big Grizz",
      team = "Space Marines",
      units = system.file("extdata", "unit-templates", "big_grizz.csv", package = "MundusCentrum")
    ),
    list(
      name = "Eric",
      team = "Space Orcs",
      units = system.file("extdata", "unit-templates", "eric.csv", package = "MundusCentrum")
    ),
    list(
      name = "Chris",
      team = "Tyrannids",
      units = system.file("extdata", "unit-templates", "chris.csv", package = "MundusCentrum")
    )
  ),
  points = 2000
)
```

### see the starting point
This is the state of the game at the beginning

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res))
knitr::kable(res)
```

## Turn play

Get a list of unit ID's to easily make the `move_unit()` calls below.

```{r}
moby_units <- read_player_map(game, "big_grizz") %>% pull(unit_name)
eric_units <- read_player_map(game, "eric") %>% pull(unit_name)
chris_units <- read_player_map(game, "chris") %>% pull(unit_name)
```

# TURN 1
Players change their maps (making orders)

```{r}
move_unit(game, "big_grizz", moby_units[1:5],   "move",  "E2")
move_unit(game, "big_grizz", moby_units[6:7],   "control","A2")
move_unit(game, "big_grizz", moby_units[11:15], "control","A6")
move_unit(game, "eric",      eric_units[1:6],   "move",  "F7")
move_unit(game, "eric",      eric_units[9],     "control","C3")
move_unit(game, "eric",      eric_units[10:11], "control","C3")
move_unit(game, "chris",     chris_units[1:9],  "control","F1")
move_unit(game, "chris",     chris_units[10:18],"move",  "F3")
move_unit(game, "chris",     chris_units[19],   "sneak", "E5")
move_unit(game, "chris",     chris_units[20],   "soar",  "D4")
```

Reconcile moves.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res))
knitr::kable(res)
```

Take a look at what individual players can see. Here's Chris' map:

```{r}
draw_map(res, "chris")
```

We're good! Move on to the next turn. _(Note: Moby managed to teleport from `A1` to `E2` aka The Gates of Moria on his first turn.)_


# TURN 2
Players change their maps (making orders)

```{r}
move_unit(game, "big_grizz", moby_units[1:5],   "move", "F1")
move_unit(game, "eric",      eric_units[1:6],   "move", "F4")
move_unit(game, "chris",     chris_units[10:18],"move", "F4")
move_unit(game, "chris",     chris_units[19],   "sneak","E7")
move_unit(game, "chris",     chris_units[20],   "soar", "B1")
```

Attempt to reconcile moves.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res, "CONFLICT!"))
knitr::kable(res)
```

### Fights are resolved
This is where the players would resolved fights however they see fit (e.g. Warhammer, chessboxing, what-have-you)

Then they adjust their maps accordingly for the outcome of the conflicts.

```{r}
move_unit(game, "eric",      eric_units[1:6],   "retreat", "F7")
move_unit(game, "chris",     chris_units[1:9],  "retreat", "F2")
```

Now we reconcile again.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res))
knitr::kable(res)
```

We're good. On to turn 3.

# TURN 3
Players change their maps (making orders)

```{r}
move_unit(game, "big_grizz", moby_units[1:5], "defend", "F1")
move_unit(game, "big_grizz", moby_units[6:7],   "move", "A3")
move_unit(game, "big_grizz", moby_units[11:15], "move", "A7")
move_unit(game, "big_grizz", moby_units[11:15], "move", "A5")
move_unit(game, "eric",      eric_units[1:6], "defend", "F7")
move_unit(game, "eric",      eric_units[7:8],   "move", "C5")
move_unit(game, "eric",      eric_units[11:12], "move", "D2")
move_unit(game, "chris",     chris_units[10:17],"move", "F2")
move_unit(game, "chris",     chris_units[18],   "move", "E5")
move_unit(game, "chris",     chris_units[20],   "soar", "B6")
```

Attempt to reconcile moves.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res))
knitr::kable(res)
```

### Vision

No conflict here, but notice how everyone's vision changes... _[WORK IN PROGRESS]_

**Grizz**
```{r}
draw_map(res, "big_grizz")
```

**Chris**
```{r}
draw_map(res, "chris")
```

**Eric**
```{r}
draw_map(res, "eric")
```

# TURN 4
Players change their maps (making orders). Renew the attack.

```{r}
move_unit(game, "big_grizz", moby_units[6:7],   "move", "B1")
move_unit(game, "big_grizz", moby_units[11:15], "move", "B5")
move_unit(game, "eric",      eric_units[7:8],   "move", "F3")
move_unit(game, "eric",      eric_units[11:12], "move", "E3")
move_unit(game, "chris",     chris_units[1:17],"attack","F1")
move_unit(game, "chris",     chris_units[18], "attack", "F7")
move_unit(game, "chris",     chris_units[19],   "sneak","F8")
move_unit(game, "chris",     chris_units[20],   "soar", "C3")
```

Attempt to reconcile moves.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res, "CONFLICT!"))
knitr::kable(res)
```

### Fights are resolved
We fight. Adjust maps accordingly for the outcome of the conflicts.

```{r}
move_unit(game, "big_grizz", moby_units[1:6], "retreat", "E2")
move_unit(game, "eric",      eric_units[1:6], "retreat", "F8")
move_unit(game, "chris",     chris_units[20], "retreat", "C5")
```

Now we reconcile again.

```{r}
res <- reconcile_player_orders(game)
print(draw_map(res, "CONFLICT!"))
knitr::kable(res)
```

### Retreats

_Here's a good question: what happens here? A large army retreats into an area where a spy has been hiding. Do they fight? Do they take casualties?_

# TURN 5
Players change their maps (making orders)...


